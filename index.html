
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Sea Turtle Runner</title>
  <style>
    :root {
      --bg: #0b1f33;
      --sea: #0f3d59;
      --sand: #e5c07b;
      --turtle: #36c2a6;
      --trash: #c94f4f;
      --star: #ffd369;
      --text: #f4f7fb;
      --btn: #3b82f6;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0; font-family: system-ui, Segoe UI, Arial; background: linear-gradient(#061425, var(--sea));
      color: var(--text); display: flex; flex-direction: column; align-items: center; min-height: 100vh;
    }
    header { text-align: center; padding: 18px 12px; }
    h1 { margin: 0 0 6px; font-size: 28px; }
    p { margin: 4px 0; opacity: 0.9; }
    .hud {
      display: flex; gap: 12px; margin: 8px 0 12px;
      font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px;
    }
    .hud span { background: rgba(255,255,255,0.08); padding: 6px 10px; border-radius: 8px; }
    #game {
      border: 3px solid rgba(255,255,255,0.15); border-radius: 12px;
      background: linear-gradient(var(--sea), #0a2f46); box-shadow: 0 10px 24px rgba(0,0,0,0.35);
      touch-action: none;
    }
    .controls {
      display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; width: 320px; max-width: 92vw; margin: 14px auto;
    }
    button {
      appearance: none; border: none; border-radius: 10px; padding: 12px;
      background: var(--btn); color: white; font-weight: 700; box-shadow: 0 6px 18px rgba(59,130,246,0.35);
      cursor: pointer; transition: transform 0.08s ease, filter 0.2s ease;
    }
    button:hover { filter: brightness(1.05); }
    button:active { transform: translateY(1px); }
    footer { margin: 18px; font-size: 12px; opacity: 0.7; }
    .overlay {
      position: absolute; inset: 0; display: flex; align-items: center; justify-content: center;
      color: var(--text); pointer-events: none;
    }
    .panel {
      pointer-events: auto; background: rgba(8,18,30,0.85); backdrop-filter: blur(8px);
      border: 1px solid rgba(255,255,255,0.12); border-radius: 14px; padding: 18px; text-align: center; max-width: 90vw;
    }
    .panel h2 { margin: 4px 0 8px; }
    .panel p { margin: 6px 0; }
    .panel .row { display: flex; gap: 10px; justify-content: center; margin-top: 10px; }
    .hidden { display: none; }
  </style>
</head>
<body>
  <header>
    <h1>Sea Turtle Runner</h1>
    <p>Jump over trash, collect stars, and keep the turtle safe.</p>
    <div class="hud">
      <span id="score">Score: 0</span>
      <span id="best">Best: 0</span>
      <span id="lives">Lives: 3</span>
    </div>
  </header>

  <canvas id="game" width="720" height="360" aria-label="Sea Turtle Runner" role="img"></canvas>

  <div class="controls">
    <button id="btnStart">Start</button>
    <button id="btnJump">Jump</button>
    <button id="btnPause">Pause</button>
  </div>

  <div class="overlay hidden" id="overlay">
    <div class="panel">
      <h2 id="panelTitle">Paused</h2>
      <p id="panelText">Press Start to continue.</p>
      <div class="row">
        <button id="overlayStart">Start</button>
        <button id="overlayRestart">Restart</button>
      </div>
    </div>
  </div>

  <footer>Tip: Space/Up arrow to jump. Mobile: use the Jump button.</footer>

  <script>
    // Canvas setup
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    // HUD elements
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const livesEl = document.getElementById('lives');

    // Controls
    const btnStart = document.getElementById('btnStart');
    const btnJump = document.getElementById('btnJump');
    const btnPause = document.getElementById('btnPause');

    // Overlay
    const overlay = document.getElementById('overlay');
    const panelTitle = document.getElementById('panelTitle');
    const panelText = document.getElementById('panelText');
    const overlayStart = document.getElementById('overlayStart');
    const overlayRestart = document.getElementById('overlayRestart');

    // Game state
    const GROUND = canvas.height - 50;
    const gravity = 0.6;
    let running = false, paused = false, frame = 0;
    let score = 0, best = +localStorage.getItem('bestTurtleScore') || 0;
    let lives = 3;

    // Player (turtle)
    const player = {
      x: 80, y: GROUND, w: 36, h: 24, vy: 0, onGround: true,
      jump() {
        if (this.onGround) { this.vy = -12; this.onGround = false; }
      },
      update() {
        this.vy += gravity;
        this.y += this.vy;
        if (this.y >= GROUND) { this.y = GROUND; this.vy = 0; this.onGround = true; }
      },
      draw() {
        // Turtle body
        ctx.fillStyle = getPulseColor('#36c2a6', '#2aa18c', 60);
        ctx.fillRect(this.x, this.y - this.h, this.w, this.h);
        // Head
        ctx.fillStyle = '#2fd5b6';
        ctx.fillRect(this.x + this.w - 8, this.y - this.h + 6, 10, 10);
        // Flippers
        ctx.fillStyle = '#29a594';
        ctx.fillRect(this.x - 6, this.y - 12, 10, 6);
        ctx.fillRect(this.x + 6, this.y - 6, 10, 6);
      }
    };

    // Obstacles (trash) and collectibles (stars)
    const obstacles = [];
    const stars = [];

    function spawn() {
      // Trash
      const size = 20 + Math.random()*25;
      obstacles.push({ x: canvas.width + 10, y: GROUND, w: size, h: size, speed: 4 + score*0.002 });
      // Stars (sometimes)
      if (Math.random() < 0.6) {
        stars.push({ x: canvas.width + 10 + Math.random()*120, y: GROUND - (60 + Math.random()*120), r: 7, speed: 4.5 + score*0.002 });
      }
    }

    function updateEntities(list) {
      for (let i = list.length - 1; i >= 0; i--) {
        list[i].x -= list[i].speed;
        if (list[i].x < -50) list.splice(i, 1);
      }
    }

    function drawBackground() {
      // Water bands
      for (let i = 0; i < 6; i++) {
        ctx.fillStyle = `rgba(255,255,255,${0.03 + i*0.01})`;
        ctx.fillRect(0, 30 + i*45 + (Math.sin(frame*0.01 + i)*4), canvas.width, 18);
      }
      // Sand
      ctx.fillStyle = '#0a2940';
      ctx.fillRect(0, GROUND+1, canvas.width, canvas.height - GROUND);
      // Bubbles
      for (let i = 0; i < 20; i++) {
        const bx = (frame*1.2 + i*60) % canvas.width;
        const by = canvas.height - (i*18 % canvas.height);
        ctx.fillStyle = 'rgba(255,255,255,0.08)';
        ctx.beginPath(); ctx.arc(bx, by, 3, 0, Math.PI*2); ctx.fill();
      }
    }

    function drawObstacles() {
      obstacles.forEach(o => {
        ctx.fillStyle = '#c94f4f'; // trash
        ctx.fillRect(o.x, o.y - o.h, o.w, o.h);
        ctx.fillStyle = 'rgba(0,0,0,0.2)';
        ctx.fillRect(o.x+2, o.y - o.h + 2, o.w-4, o.h-4);
      });
    }

    function drawStars() {
      stars.forEach(s => {
        drawStar(s.x, s.y, 5, s.r, s.r/2, '#ffd369');
      });
    }

    function drawStar(x, y, spikes, outerRadius, innerRadius, color) {
      let rot = Math.PI / 2 * 3, cx = x, cy = y;
      let step = Math.PI / spikes;
      ctx.beginPath(); ctx.moveTo(cx, cy - outerRadius);
      for (let i = 0; i < spikes; i++) {
        ctx.lineTo(cx + Math.cos(rot) * outerRadius, cy + Math.sin(rot) * outerRadius);
        rot += step;
        ctx.lineTo(cx + Math.cos(rot) * innerRadius, cy + Math.sin(rot) * innerRadius);
        rot += step;
      }
      ctx.lineTo(cx, cy - outerRadius); ctx.closePath();
      ctx.fillStyle = color; ctx.fill();
    }

    function collideRect(a, b) {
      return a.x < b.x + b.w && a.x + a.w > b.x && a.y - a.h < b.y && a.y > b.y - b.h;
    }

    function collideCircleRect(circle, rect) {
      const distX = Math.abs(circle.x - (rect.x + rect.w/2));
      const distY = Math.abs(circle.y - (rect.y - rect.h/2));
      if (distX > (rect.w/2 + circle.r) || distY > (rect.h/2 + circle.r)) return false;
      if (distX <= (rect.w/2) || distY <= (rect.h/2)) return true;
      const dx = distX - rect.w/2, dy = distY - rect.h/2;
      return (dx*dx + dy*dy) <= (circle.r*circle.r);
    }

    function getPulseColor(a, b, speed) {
      // simple color tween between two hex colors
      function hexToRgb(h){const r=parseInt(h.slice(1,3),16),g=parseInt(h.slice(3,5),16),bl=parseInt(h.slice(5,7),16);return [r,g,bl];}
      const [r1,g1,b1] = hexToRgb(a), [r2,g2,b2] = hexToRgb(b);
      const t = (Math.sin(frame/speed) + 1)/2;
      const r = Math.round(r1 + (r2 - r1)*t);
      const g = Math.round(g1 + (g2 - g1)*t);
      const bl = Math.round(b1 + (b2 - b1)*t);
      return `rgb(${r},${g},${bl})`;
    }

    function reset() {
      score = 0; lives = 3; frame = 0; paused = false;
      player.x = 80; player.y = GROUND; player.vy = 0; player.onGround = true;
      obstacles.length = 0; stars.length = 0;
      updateHud();
    }

    function updateHud() {
      scoreEl.textContent = `Score: ${score}`;
      bestEl.textContent = `Best: ${best}`;
      livesEl.textContent = `Lives: ${lives}`;
    }

    function gameOver() {
      running = false; paused = true;
      best = Math.max(best, score);
      localStorage.setItem('bestTurtleScore', best);
      panelTitle.textContent = 'Game Over';
      panelText.textContent = `Final Score: ${score} â€¢ Best: ${best}`;
      overlay.classList.remove('hidden');
    }

    function tick() {
      if (!running || paused) return;
      frame++;

      // Logic
      if (frame % 80 === 0) spawn();
      player.update();
      updateEntities(obstacles);
      updateEntities(stars);

      // Collisions: trash
      for (let i = obstacles.length - 1; i >= 0; i--) {
        if (collideRect(player, obstacles[i])) {
          obstacles.splice(i, 1);
          lives--;
          if (lives <= 0) { updateHud(); gameOver(); return; }
        }
      }

      // Collisions: stars
      for (let i = stars.length - 1; i >= 0; i--) {
        if (collideCircleRect({x: stars[i].x, y: stars[i].y, r: stars[i].r}, {x: player.x, y: player.y, w: player.w, h: player.h})) {
          stars.splice(i, 1);
          score += 10;
        }
      }

      // Passive scoring + difficulty curve
      score += 0.1;

      // Draw
      ctx.clearRect(0,0,canvas.width,canvas.height);
      drawBackground();
      drawStars();
      drawObstacles();
      player.draw();

      // Foreground HUD
      ctx.fillStyle = 'rgba(255,255,255,0.08)';
      ctx.fillRect(0, GROUND+1, canvas.width, canvas.height - GROUND);
      ctx.fillStyle = '#ffffffcc';
      ctx.font = '14px Segoe UI';
      ctx.fillText(`Score: ${Math.floor(score)}`, 12, 22);

      updateHud();
      requestAnimationFrame(tick);
    }

    // Input
    function jump() { player.jump(); }
    window.addEventListener('keydown', e => {
      if (e.code === 'Space' || e.code === 'ArrowUp') jump();
      if (e.code === 'KeyP') togglePause();
    });
    btnJump.addEventListener('click', jump);

    function togglePause() {
      if (!running) return;
      paused = !paused;
      if (paused) {
        panelTitle.textContent = 'Paused';
        panelText.textContent = 'Press Start to continue.';
        overlay.classList.remove('hidden');
      } else {
        overlay.classList.add('hidden');
        requestAnimationFrame(tick);
      }
    }
    btnPause.addEventListener('click', togglePause);

    function start() {
      if (!running) reset();
      running = true; paused = false; overlay.classList.add('hidden');
      requestAnimationFrame(tick);
    }
    btnStart.addEventListener('click', start);
    overlayStart.addEventListener('click', start);
    overlayRestart.addEventListener('click', () => { reset(); start(); });

    // Fit canvas to screen on mobile while keeping aspect
    function fitCanvas() {
      const scale = Math.min(window.innerWidth / canvas.width, (window.innerHeight - 220) / canvas.height);
      canvas.style.transform = `scale(${Math.max(0.7, Math.min(1.2, scale))})`;
      canvas.style.transformOrigin = 'top center';
    }
    window.addEventListener('resize', fitCanvas);
    fitCanvas();
  </script>
</body>
</html>

